<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 11px;
      background: var(--figma-color-bg, #2c2c2c);
      color: var(--figma-color-text, rgba(255, 255, 255, 0.9));
      overflow: hidden;
      user-select: none;
    }

    /* ---- Shared toggle bar (used in both collapsed and expanded) ---- */
    .toggle-bar {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 8px;
      cursor: pointer;
      white-space: nowrap;
      width: 100%;
    }

    .toggle-bar:hover {
      background: var(--figma-color-bg-secondary, rgba(255, 255, 255, 0.06));
      border-radius: 4px;
    }

    .toggle-bar .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .toggle-bar .label {
      font-weight: 600;
      font-size: 11px;
      flex: 1;
    }

    .toggle-bar .chevron {
      font-size: 10px;
      color: var(--figma-color-text-secondary, rgba(255, 255, 255, 0.5));
      flex-shrink: 0;
    }

    /* ---- Panel container ---- */
    .expanded-view {
      display: flex;
      flex-direction: column;
      width: 220px;
      padding: 0;
      overflow: hidden;
    }

    .detail-wrap {
      display: none;
    }

    .detail-wrap.open {
      display: block;
      padding: 4px 0 8px 0;
    }

    .detail-lines {
      display: flex;
      flex-direction: column;
      gap: 2px;
      padding: 0 10px;
    }

    .info-line {
      font-size: 10px;
      color: var(--figma-color-text-secondary, rgba(255, 255, 255, 0.6));
      line-height: 1.4;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .info-line.error-line {
      color: #f24822;
    }

    .info-line.reconnect-line {
      color: #f5a623;
    }

    /* ---- Dot color states ---- */
    .dot.loading {
      background: #f5a623;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .dot.active {
      background: #18a957;
      box-shadow: 0 0 6px rgba(24, 169, 87, 0.6);
      animation: glow 2s ease-in-out infinite;
    }

    .dot.error {
      background: #f24822;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }

    @keyframes glow {
      0%, 100% { box-shadow: 0 0 4px rgba(24, 169, 87, 0.4); }
      50% { box-shadow: 0 0 8px rgba(24, 169, 87, 0.8); }
    }

    /* Activity indicator — cycles colors while bridge is working */
    @keyframes colorCycle {
      0%   { background: #a259ff; box-shadow: 0 0 6px rgba(162, 89, 255, 0.6); }
      25%  { background: #18a0fb; box-shadow: 0 0 6px rgba(24, 160, 251, 0.6); }
      50%  { background: #ff6b6b; box-shadow: 0 0 6px rgba(255, 107, 107, 0.6); }
      75%  { background: #f5a623; box-shadow: 0 0 6px rgba(245, 166, 35, 0.6); }
      100% { background: #a259ff; box-shadow: 0 0 6px rgba(162, 89, 255, 0.6); }
    }

    .dot.working {
      animation: colorCycle 1.5s linear infinite !important;
    }

    /* Light theme support */
    @media (prefers-color-scheme: light) {
      body {
        background: #f5f5f5;
        color: #333;
      }
      .info-line {
        color: #666;
      }
      .toggle-bar:hover {
        background: rgba(0, 0, 0, 0.05);
      }
      .toggle-bar .chevron {
        color: #999;
      }
    }
  </style>
</head>
<body>
  <div class="expanded-view">
    <div class="toggle-bar" id="toggle-bar" onclick="togglePanel()">
      <div class="dot loading" id="status-dot"></div>
      <span class="label" id="status-title">MCP Bridge</span>
      <span class="chevron" id="chevron">&#9660;</span>
    </div>
    <div class="detail-wrap" id="detail-wrap">
      <div class="detail-lines">
        <div class="info-line" id="connection-line">Scanning for servers...</div>
        <div class="info-line" id="activity-line">No activity yet</div>
        <div class="info-line error-line" id="error-line" style="display:none"></div>
        <div class="info-line reconnect-line" id="reconnect-line" style="display:none"></div>
      </div>
    </div>
  </div>

  <script>
    // ============================================================================
    // COLLAPSIBLE UI — expand/collapse with resize message to code.js
    // ============================================================================
    var isExpanded = false;

    function resizeUI(width, height) {
      parent.postMessage({ pluginMessage: { type: 'RESIZE_UI', width: width, height: height } }, '*');
    }

    function togglePanel() {
      isExpanded = !isExpanded;
      var wrap = document.getElementById('detail-wrap');
      var chevron = document.getElementById('chevron');
      if (isExpanded) {
        wrap.classList.add('open');
        chevron.innerHTML = '&#9650;';
        resizeUI(220, 120);
      } else {
        wrap.classList.remove('open');
        chevron.innerHTML = '&#9660;';
        resizeUI(220, 32);
      }
    }

    // ============================================================================
    // GLOBAL STATE - Data storage for Puppeteer/MCP access
    // ============================================================================
    window.__figmaVariablesData = null;
    window.__figmaVariablesReady = false;
    window.__figmaComponentData = null;
    window.__figmaComponentRequests = new Map();
    window.__figmaPendingRequests = new Map();

    let requestIdCounter = 0;

    // ============================================================================
    // STATUS TRACKING — shared state for UI updates
    // ============================================================================
    var statusState = {
      dotClass: 'loading',
      title: 'MCP Bridge',
      connectionText: 'Scanning for servers...',
      lastError: null,
      reconnectText: null,
      lastActivityTs: 0
    };

    function setDotClass(cls) {
      statusState.dotClass = cls;
      document.getElementById('status-dot').className = 'dot ' + cls;
    }

    function updateStatusPanel() {
      document.getElementById('status-title').textContent = statusState.title;
      document.getElementById('connection-line').textContent = statusState.connectionText;

      var errEl = document.getElementById('error-line');
      if (statusState.lastError) {
        errEl.textContent = statusState.lastError;
        errEl.style.display = '';
      } else {
        errEl.style.display = 'none';
      }

      var reconEl = document.getElementById('reconnect-line');
      if (statusState.reconnectText) {
        reconEl.textContent = statusState.reconnectText;
        reconEl.style.display = '';
      } else {
        reconEl.style.display = 'none';
      }
    }

    var workingTimer = null;
    function touchActivity() {
      statusState.lastActivityTs = Date.now();

      // Start color cycling while active, stop after 3s idle
      var dot = document.getElementById('status-dot');
      dot.classList.add('working');
      clearTimeout(workingTimer);
      workingTimer = setTimeout(function() {
        dot.classList.remove('working');
      }, 3000);
    }

    // Update activity line every second
    setInterval(function() {
      if (statusState.lastActivityTs > 0) {
        var ago = Math.round((Date.now() - statusState.lastActivityTs) / 1000);
        var text;
        if (ago < 2) text = 'Last activity: just now';
        else if (ago < 60) text = 'Last activity: ' + ago + 's ago';
        else if (ago < 3600) text = 'Last activity: ' + Math.floor(ago / 60) + 'm ago';
        else text = 'Last activity: ' + Math.floor(ago / 3600) + 'h ago';
        document.getElementById('activity-line').textContent = text;
      }
    }, 1000);

    // Legacy updateStatus — called by message handler
    function updateStatus(state, isActive, isError) {
      setDotClass(isError ? 'error' : (isActive ? 'active' : 'loading'));
      statusState.title = isActive ? 'MCP Ready' : (isError ? 'MCP Error' : 'MCP Bridge');
      updateStatusPanel();
    }

    // ============================================================================
    // COMMAND INFRASTRUCTURE - Generic plugin command sender
    // ============================================================================
    window.sendPluginCommand = (type, params, timeoutMs) => {
      timeoutMs = timeoutMs || 15000;
      return new Promise((resolve, reject) => {
        const requestId = type.toLowerCase() + '_' + (++requestIdCounter) + '_' + Date.now();

        const timeoutId = setTimeout(() => {
          if (window.__figmaPendingRequests.has(requestId)) {
            window.__figmaPendingRequests.delete(requestId);
            reject(new Error(type + ' request timed out after ' + timeoutMs + 'ms'));
          }
        }, timeoutMs);

        window.__figmaPendingRequests.set(requestId, { resolve: resolve, reject: reject, type: type, timeoutId: timeoutId });

        var message = { type: type, requestId: requestId };
        for (var key in params) {
          if (params.hasOwnProperty(key)) {
            message[key] = params[key];
          }
        }

        parent.postMessage({ pluginMessage: message }, '*');
        console.log('[MCP Bridge] Sent:', type);
      });
    };

    // ============================================================================
    // VARIABLE OPERATIONS
    // ============================================================================

    window.executeCode = (code, timeout) => {
      return window.sendPluginCommand('EXECUTE_CODE', { code: code, timeout: timeout || 5000 }, (timeout || 5000) + 2000)
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    window.updateVariable = (variableId, modeId, value) => {
      return window.sendPluginCommand('UPDATE_VARIABLE', { variableId: variableId, modeId: modeId, value: value })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    window.createVariable = (name, collectionId, resolvedType, options) => {
      var params = { name: name, collectionId: collectionId, resolvedType: resolvedType };
      if (options) {
        if (options.valuesByMode) params.valuesByMode = options.valuesByMode;
        if (options.description) params.description = options.description;
        if (options.scopes) params.scopes = options.scopes;
      }
      return window.sendPluginCommand('CREATE_VARIABLE', params)
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    window.createVariableCollection = (name, options) => {
      var params = { name: name };
      if (options) {
        if (options.initialModeName) params.initialModeName = options.initialModeName;
        if (options.additionalModes) params.additionalModes = options.additionalModes;
      }
      return window.sendPluginCommand('CREATE_VARIABLE_COLLECTION', params)
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    window.deleteVariable = (variableId) => {
      return window.sendPluginCommand('DELETE_VARIABLE', { variableId: variableId })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    window.deleteVariableCollection = (collectionId) => {
      return window.sendPluginCommand('DELETE_VARIABLE_COLLECTION', { collectionId: collectionId })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    window.renameVariable = (variableId, newName) => {
      return window.sendPluginCommand('RENAME_VARIABLE', { variableId: variableId, newName: newName })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    window.setVariableDescription = (variableId, description) => {
      return window.sendPluginCommand('SET_VARIABLE_DESCRIPTION', { variableId: variableId, description: description })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    window.addMode = (collectionId, modeName) => {
      return window.sendPluginCommand('ADD_MODE', { collectionId: collectionId, modeName: modeName })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    window.renameMode = (collectionId, modeId, newName) => {
      return window.sendPluginCommand('RENAME_MODE', { collectionId: collectionId, modeId: modeId, newName: newName })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    window.refreshVariables = () => {
      return window.sendPluginCommand('REFRESH_VARIABLES', {}, 300000)
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // ============================================================================
    // COMPONENT OPERATIONS
    // ============================================================================

    window.getLocalComponents = () => {
      return window.sendPluginCommand('GET_LOCAL_COMPONENTS', {}, 300000)
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    window.instantiateComponent = (componentKey, options) => {
      var params = { componentKey: componentKey };
      if (options) {
        if (options.nodeId) params.nodeId = options.nodeId;
        if (options.position) params.position = options.position;
        if (options.size) params.size = options.size;
        if (options.overrides) params.overrides = options.overrides;
        if (options.variant) params.variant = options.variant;
        if (options.parentId) params.parentId = options.parentId;
      }
      return window.sendPluginCommand('INSTANTIATE_COMPONENT', params)
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    window.requestComponentData = (nodeId) => {
      return new Promise((resolve, reject) => {
        const requestId = 'component_' + (++requestIdCounter) + '_' + Date.now();
        window.__figmaComponentRequests.set(requestId, { resolve: resolve, reject: reject });
        parent.postMessage({ pluginMessage: { type: 'GET_COMPONENT', requestId: requestId, nodeId: nodeId } }, '*');
        setTimeout(() => {
          if (window.__figmaComponentRequests.has(requestId)) {
            window.__figmaComponentRequests.delete(requestId);
            reject(new Error('Component request timed out'));
          }
        }, 10000);
      });
    };

    // ============================================================================
    // NEW: COMPONENT PROPERTY MANAGEMENT
    // ============================================================================

    // Set component/node description
    window.setNodeDescription = (nodeId, description, descriptionMarkdown) => {
      return window.sendPluginCommand('SET_NODE_DESCRIPTION', {
        nodeId: nodeId,
        description: description,
        descriptionMarkdown: descriptionMarkdown
      }).catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Add a component property (BOOLEAN, TEXT, INSTANCE_SWAP, VARIANT)
    // Note: We use 'propertyType' instead of 'type' to avoid collision with message type field
    window.addComponentProperty = (nodeId, propertyName, type, defaultValue, options) => {
      var params = { nodeId: nodeId, propertyName: propertyName, propertyType: type, defaultValue: defaultValue };
      if (options) {
        if (options.preferredValues) params.preferredValues = options.preferredValues;
      }
      return window.sendPluginCommand('ADD_COMPONENT_PROPERTY', params)
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Edit an existing component property
    window.editComponentProperty = (nodeId, propertyName, newValue) => {
      return window.sendPluginCommand('EDIT_COMPONENT_PROPERTY', {
        nodeId: nodeId,
        propertyName: propertyName,
        newValue: newValue
      }).catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Delete a component property
    window.deleteComponentProperty = (nodeId, propertyName) => {
      return window.sendPluginCommand('DELETE_COMPONENT_PROPERTY', {
        nodeId: nodeId,
        propertyName: propertyName
      }).catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // ============================================================================
    // NEW: NODE MANIPULATION
    // ============================================================================

    // Resize any node
    window.resizeNode = (nodeId, width, height, withConstraints) => {
      return window.sendPluginCommand('RESIZE_NODE', {
        nodeId: nodeId,
        width: width,
        height: height,
        withConstraints: withConstraints !== false
      }).catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Move/position a node
    window.moveNode = (nodeId, x, y) => {
      return window.sendPluginCommand('MOVE_NODE', { nodeId: nodeId, x: x, y: y })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Set node fills (colors)
    window.setNodeFills = (nodeId, fills) => {
      return window.sendPluginCommand('SET_NODE_FILLS', { nodeId: nodeId, fills: fills })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Set node strokes
    window.setNodeStrokes = (nodeId, strokes, strokeWeight) => {
      var params = { nodeId: nodeId, strokes: strokes };
      if (strokeWeight !== undefined) params.strokeWeight = strokeWeight;
      return window.sendPluginCommand('SET_NODE_STROKES', params)
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Set node opacity
    window.setNodeOpacity = (nodeId, opacity) => {
      return window.sendPluginCommand('SET_NODE_OPACITY', { nodeId: nodeId, opacity: opacity })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Set node corner radius
    window.setNodeCornerRadius = (nodeId, radius) => {
      return window.sendPluginCommand('SET_NODE_CORNER_RADIUS', { nodeId: nodeId, radius: radius })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Clone a node
    window.cloneNode = (nodeId) => {
      return window.sendPluginCommand('CLONE_NODE', { nodeId: nodeId })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Delete a node
    window.deleteNode = (nodeId) => {
      return window.sendPluginCommand('DELETE_NODE', { nodeId: nodeId })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Rename a node
    window.renameNode = (nodeId, newName) => {
      return window.sendPluginCommand('RENAME_NODE', { nodeId: nodeId, newName: newName })
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Set text content (for text nodes)
    window.setTextContent = (nodeId, text, options) => {
      var params = { nodeId: nodeId, text: text };
      if (options) {
        if (options.fontSize) params.fontSize = options.fontSize;
        if (options.fontWeight) params.fontWeight = options.fontWeight;
        if (options.fontFamily) params.fontFamily = options.fontFamily;
      }
      return window.sendPluginCommand('SET_TEXT_CONTENT', params)
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Create a new node as child
    window.createChildNode = (parentId, nodeType, properties) => {
      return window.sendPluginCommand('CREATE_CHILD_NODE', {
        parentId: parentId,
        nodeType: nodeType,
        properties: properties || {}
      }).catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // ============================================================================
    // NEW: SCREENSHOT & INSTANCE PROPERTIES (Fix for visual validation loop)
    // ============================================================================

    // Capture screenshot using plugin's exportAsync (reads current plugin state, not cloud)
    // This solves the race condition where REST API screenshots show stale state
    window.captureScreenshot = (nodeId, options) => {
      var params = { nodeId: nodeId };
      if (options) {
        if (options.format) params.format = options.format;  // PNG, JPG, SVG
        if (options.scale) params.scale = options.scale;      // 1, 2, 4, etc.
      }
      return window.sendPluginCommand('CAPTURE_SCREENSHOT', params, 30000)
        .catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // Set component instance properties (TEXT, BOOLEAN, INSTANCE_SWAP, VARIANT)
    // This is the correct way to update component instances vs direct text node editing
    window.setInstanceProperties = (nodeId, properties) => {
      return window.sendPluginCommand('SET_INSTANCE_PROPERTIES', {
        nodeId: nodeId,
        properties: properties
      }).catch(function(err) { return { success: false, error: err.message || String(err) }; });
    };

    // ============================================================================
    // WEBSOCKET BRIDGE CLIENT - Fallback transport when CDP is unavailable
    // ============================================================================
    (function() {
      // Port range for multi-instance support (matches server's port-discovery.ts)
      var WS_PORT_RANGE_START = 9223;
      var WS_PORT_RANGE_END = 9232;

      // Multi-connection state: plugin connects to ALL active MCP servers
      // so that every Claude tab/CLI instance gets Figma access.
      var activeConnections = []; // Array of { port, ws }
      var wsReconnectDelay = 500;
      var wsMaxReconnectDelay = 30000; // 30s max backoff (was 5s)
      var scanFailures = 0; // Count of consecutive full-scan failures (no servers found)
      var isScanning = false;
      var rescanTimerId = null;

      // Backward-compat: ws and wsConnected reflect "at least one connection"
      var ws = null;
      var wsPort = null;
      var wsConnected = false;

      // Method-to-function mapping
      var methodMap = {
        'EXECUTE_CODE': function(params) { return window.executeCode(params.code, params.timeout); },
        'UPDATE_VARIABLE': function(params) { return window.updateVariable(params.variableId, params.modeId, params.value); },
        'CREATE_VARIABLE': function(params) { return window.createVariable(params.name, params.collectionId, params.resolvedType, params); },
        'DELETE_VARIABLE': function(params) { return window.deleteVariable(params.variableId); },
        'DELETE_VARIABLE_COLLECTION': function(params) { return window.deleteVariableCollection(params.collectionId); },
        'RENAME_VARIABLE': function(params) { return window.renameVariable(params.variableId, params.newName); },
        'SET_VARIABLE_DESCRIPTION': function(params) { return window.setVariableDescription(params.variableId, params.description); },
        'ADD_MODE': function(params) { return window.addMode(params.collectionId, params.modeName); },
        'RENAME_MODE': function(params) { return window.renameMode(params.collectionId, params.modeId, params.newName); },
        'REFRESH_VARIABLES': function() { return window.refreshVariables(); },
        'CREATE_VARIABLE_COLLECTION': function(params) { return window.createVariableCollection(params.name, params); },
        'GET_LOCAL_COMPONENTS': function() { return window.getLocalComponents(); },
        'INSTANTIATE_COMPONENT': function(params) { return window.instantiateComponent(params.componentKey, params); },
        'GET_COMPONENT': function(params) { return window.requestComponentData(params.nodeId); },
        'SET_NODE_DESCRIPTION': function(params) { return window.setNodeDescription(params.nodeId, params.description, params.descriptionMarkdown); },
        'ADD_COMPONENT_PROPERTY': function(params) { return window.addComponentProperty(params.nodeId, params.propertyName, params.propertyType, params.defaultValue, params); },
        'EDIT_COMPONENT_PROPERTY': function(params) { return window.editComponentProperty(params.nodeId, params.propertyName, params.newValue); },
        'DELETE_COMPONENT_PROPERTY': function(params) { return window.deleteComponentProperty(params.nodeId, params.propertyName); },
        'RESIZE_NODE': function(params) { return window.resizeNode(params.nodeId, params.width, params.height, params.withConstraints); },
        'MOVE_NODE': function(params) { return window.moveNode(params.nodeId, params.x, params.y); },
        'SET_NODE_FILLS': function(params) { return window.setNodeFills(params.nodeId, params.fills); },
        'SET_NODE_STROKES': function(params) { return window.setNodeStrokes(params.nodeId, params.strokes, params.strokeWeight); },
        'SET_NODE_OPACITY': function(params) { return window.setNodeOpacity(params.nodeId, params.opacity); },
        'SET_NODE_CORNER_RADIUS': function(params) { return window.setNodeCornerRadius(params.nodeId, params.radius); },
        'CLONE_NODE': function(params) { return window.cloneNode(params.nodeId); },
        'DELETE_NODE': function(params) { return window.deleteNode(params.nodeId); },
        'RENAME_NODE': function(params) { return window.renameNode(params.nodeId, params.newName); },
        'SET_TEXT_CONTENT': function(params) { return window.setTextContent(params.nodeId, params.text, params); },
        'CREATE_CHILD_NODE': function(params) { return window.createChildNode(params.parentId, params.nodeType, params.properties); },
        'CAPTURE_SCREENSHOT': function(params) { return window.captureScreenshot(params.nodeId, params); },
        'SET_INSTANCE_PROPERTIES': function(params) { return window.setInstanceProperties(params.nodeId, params.properties); },
        'GET_VARIABLES_DATA': function() {
          // Return the cached variables data directly
          if (window.__figmaVariablesReady && window.__figmaVariablesData) {
            return Promise.resolve(window.__figmaVariablesData);
          }
          return Promise.reject(new Error('Variables data not ready. Make sure the Desktop Bridge plugin has loaded.'));
        },
        'GET_FILE_INFO': function() {
          return window.sendPluginCommand('GET_FILE_INFO', {});
        },
        'CLEAR_CONSOLE': function() {
          // Console buffer is maintained server-side; this is a no-op ack
          return Promise.resolve({ cleared: true });
        },
        'RELOAD_UI': function() {
          return window.sendPluginCommand('RELOAD_UI', {});
        }
      };

      /**
       * Update the expanded status panel with current connection info.
       */
      function updateConnectionStatus() {
        var live = activeConnections.filter(function(c) { return c.ws.readyState === 1; });
        if (live.length > 0) {
          var ports = live.map(function(c) { return ':' + c.port; }).join(', ');
          statusState.connectionText = 'Connected to ' + live.length + ' server(s): ' + ports;
          setDotClass('active');
          statusState.reconnectText = null;
          statusState.lastError = null;
        } else if (isScanning) {
          statusState.connectionText = 'Scanning for servers...';
          setDotClass('loading');
        } else {
          statusState.connectionText = 'No servers found';
          setDotClass('loading');
        }
        updateStatusPanel();
      }

      /**
       * Check if we already have a connection to a specific port.
       */
      function isPortConnected(port) {
        for (var i = 0; i < activeConnections.length; i++) {
          if (activeConnections[i].port === port && activeConnections[i].ws.readyState === 1) {
            return true;
          }
        }
        return false;
      }

      /**
       * Remove a connection from the active list and update compat state.
       */
      function removeConnection(port) {
        activeConnections = activeConnections.filter(function(c) { return c.port !== port; });
        updateCompatState();
        updateConnectionStatus();
      }

      /**
       * Update backward-compat variables (ws, wsPort, wsConnected).
       */
      function updateCompatState() {
        var live = activeConnections.filter(function(c) { return c.ws.readyState === 1; });
        wsConnected = live.length > 0;
        if (live.length > 0) {
          ws = live[0].ws;
          wsPort = live[0].port;
        } else {
          ws = null;
          wsPort = null;
        }
      }

      /**
       * Initialize a new connection to a server: send FILE_INFO, variables, attach handlers.
       */
      function initializeConnection(connWs, port) {
        // Forward cached variables if available
        if (window.__figmaVariablesReady && window.__figmaVariablesData) {
          connWs.send(JSON.stringify({
            type: 'VARIABLES_DATA',
            data: window.__figmaVariablesData
          }));
        }

        // Proactively report file identity to this server
        window.sendPluginCommand('GET_FILE_INFO', {})
          .then(function(info) {
            if (connWs.readyState === 1 && info && info.success !== false) {
              connWs.send(JSON.stringify({ type: 'FILE_INFO', data: info.fileInfo || info }));
            }
          })
          .catch(function() { /* non-critical */ });
      }

      /**
       * Scan the port range and connect to ALL active MCP servers.
       * Reconnects forever with backoff (no max attempt limit).
       */
      function wsScanAndConnect() {
        if (isScanning) return;
        isScanning = true;

        var portsToTry = [];
        for (var p = WS_PORT_RANGE_START; p <= WS_PORT_RANGE_END; p++) {
          // Skip ports we're already connected to
          if (!isPortConnected(p)) {
            portsToTry.push(p);
          }
        }

        if (portsToTry.length === 0) {
          isScanning = false;
          return;
        }

        console.log('[MCP Bridge] Scanning ports ' + WS_PORT_RANGE_START + '-' + WS_PORT_RANGE_END + ' for MCP servers...');
        updateConnectionStatus();

        var foundAny = false;
        var pending = portsToTry.length;

        portsToTry.forEach(function(port) {
          try {
            var testWs = new WebSocket('ws://localhost:' + port);

            var timeout = setTimeout(function() {
              if (testWs.readyState !== 1) {
                testWs.close();
              }
            }, 3000);

            testWs.onopen = function() {
              clearTimeout(timeout);
              foundAny = true;

              // Add to active connections
              activeConnections.push({ port: port, ws: testWs });
              updateCompatState();
              updateConnectionStatus();

              console.log('[MCP Bridge] WebSocket connected to port ' + port + ' (' + activeConnections.length + ' server(s) total)');

              // Attach handlers for this connection
              attachWsHandlers(testWs, port);

              // Send file identity and variables to this server
              initializeConnection(testWs, port);

              pending--;
              if (pending <= 0) {
                isScanning = false;
                if (foundAny) {
                  wsReconnectDelay = 500;
                  scanFailures = 0;
                  statusState.reconnectText = null;
                  statusState.lastError = null;
                  updateConnectionStatus();
                }
              }
            };

            testWs.onerror = function() {
              clearTimeout(timeout);
              pending--;
              if (pending <= 0) {
                isScanning = false;
                if (!foundAny && activeConnections.length === 0) {
                  // No servers found at all — retry with backoff (forever)
                  scanFailures++;
                  var delay = wsReconnectDelay;
                  statusState.reconnectText = 'Scanning... (attempt ' + scanFailures + ', next in ' + Math.round(delay / 1000) + 's)';
                  updateConnectionStatus();
                  console.log('[MCP Bridge] No MCP server found, retrying in ' + delay + 'ms (attempt ' + scanFailures + ')');
                  setTimeout(wsScanAndConnect, delay);
                  wsReconnectDelay = Math.min(wsReconnectDelay * 1.5, wsMaxReconnectDelay);
                }
              }
            };

            testWs.onclose = function() {
              clearTimeout(timeout);
              pending--;
              if (pending <= 0 && !foundAny && activeConnections.length === 0) {
                isScanning = false;
                scanFailures++;
                var delay = wsReconnectDelay;
                statusState.reconnectText = 'Scanning... (attempt ' + scanFailures + ', next in ' + Math.round(delay / 1000) + 's)';
                updateConnectionStatus();
                setTimeout(wsScanAndConnect, delay);
                wsReconnectDelay = Math.min(wsReconnectDelay * 1.5, wsMaxReconnectDelay);
              }
            };
          } catch (e) {
            pending--;
          }
        });
      }

      /**
       * Reconnect a specific port that disconnected.
       * Tries the same port up to 3 times, then falls back to full rescan.
       */
      function wsReconnectPort(port, attempt) {
        attempt = attempt || 1;
        var maxPortAttempts = 3;

        try {
          var testWs = new WebSocket('ws://localhost:' + port);
          var timeout = setTimeout(function() {
            if (testWs.readyState !== 1) {
              testWs.close();
              if (attempt < maxPortAttempts) {
                console.log('[MCP Bridge] Port ' + port + ' retry ' + (attempt + 1) + '/' + maxPortAttempts);
                setTimeout(function() { wsReconnectPort(port, attempt + 1); }, 1000 * attempt);
              } else {
                console.log('[MCP Bridge] Port ' + port + ' unavailable after ' + maxPortAttempts + ' attempts, rescanning...');
                statusState.lastError = 'Port ' + port + ' unavailable';
                updateConnectionStatus();
                wsScanAndConnect();
              }
            }
          }, 2000);

          testWs.onopen = function() {
            clearTimeout(timeout);
            activeConnections.push({ port: port, ws: testWs });
            updateCompatState();
            scanFailures = 0;
            statusState.lastError = null;
            statusState.reconnectText = null;
            updateConnectionStatus();
            console.log('[MCP Bridge] Reconnected to port ' + port + ' (' + activeConnections.length + ' server(s) total)');
            attachWsHandlers(testWs, port);
            initializeConnection(testWs, port);
          };

          testWs.onerror = function() {
            clearTimeout(timeout);
            if (attempt < maxPortAttempts) {
              setTimeout(function() { wsReconnectPort(port, attempt + 1); }, 1000 * attempt);
            } else {
              console.log('[MCP Bridge] Port ' + port + ' unavailable, rescanning...');
              statusState.lastError = 'Port ' + port + ' unavailable';
              updateConnectionStatus();
              wsScanAndConnect();
            }
          };
        } catch (e) {
          wsScanAndConnect();
        }
      }

      /**
       * Attach message/close/error handlers to an established WebSocket connection.
       */
      function attachWsHandlers(activeWs, port) {
        activeWs.onmessage = function(event) {
          touchActivity();
          try {
            var message = JSON.parse(event.data);
            if (!message.id || !message.method) {
              console.log('[MCP Bridge] WS:' + port + ': Ignoring malformed message');
              return;
            }

            var handler = methodMap[message.method];
            if (!handler) {
              activeWs.send(JSON.stringify({ id: message.id, error: 'Unknown method: ' + message.method }));
              return;
            }

            // Call the handler (returns a Promise) and send back the result
            Promise.resolve(handler(message.params || {}))
              .then(function(result) {
                if (activeWs.readyState === 1) {
                  activeWs.send(JSON.stringify({ id: message.id, result: result }));
                }
              })
              .catch(function(err) {
                if (activeWs.readyState === 1) {
                  activeWs.send(JSON.stringify({ id: message.id, error: err.message || String(err) }));
                }
              });
          } catch (e) {
            console.error('[MCP Bridge] WS:' + port + ': Failed to process message:', e);
          }
        };

        activeWs.onclose = function(event) {
          // Remove this connection from active list
          removeConnection(port);
          console.log('[MCP Bridge] WebSocket disconnected from port ' + port + ' (' + activeConnections.length + ' server(s) remaining)');

          // If replaced by same file reconnecting (e.g., plugin reloaded), stop
          // reconnecting — the new connection is authoritative for this file.
          var wasReplaced = (event.code === 1000 && (
            event.reason === 'Replaced by new connection' ||
            event.reason === 'Replaced by same file reconnection'
          ));
          if (wasReplaced) {
            console.log('[MCP Bridge] WebSocket:' + port + ': replaced by newer connection, stopping reconnect');
            return;
          }

          // Try to reconnect to this specific port (independent retry, doesn't affect scan counter)
          statusState.reconnectText = 'Reconnecting to :' + port + '...';
          updateConnectionStatus();
          setTimeout(function() { wsReconnectPort(port); }, 500);
        };

        activeWs.onerror = function() {
          // onclose will fire after this, triggering reconnect
        };
      }

      /**
       * Broadcast a message to ALL active WebSocket connections.
       * Events like variable changes, selections, document changes need to
       * reach every MCP server instance so they all have current state.
       */
      function broadcastToAll(message) {
        var json = JSON.stringify(message);
        activeConnections.forEach(function(conn) {
          if (conn.ws.readyState === 1) {
            try { conn.ws.send(json); } catch(e) { /* ignore send errors */ }
          }
        });
      }

      // Forward VARIABLES_DATA to all connected MCP servers
      window.__wsForwardVariables = function(data) {
        if (wsConnected) {
          broadcastToAll({ type: 'VARIABLES_DATA', data: data });
        }
      };

      // Forward DOCUMENT_CHANGE events to all servers for cache invalidation
      window.__wsForwardDocumentChange = function(data) {
        if (wsConnected) {
          broadcastToAll({ type: 'DOCUMENT_CHANGE', data: data });
        }
      };

      // Forward CONSOLE_CAPTURE events to all servers for console monitoring
      window.__wsForwardConsoleCapture = function(data) {
        if (wsConnected) {
          broadcastToAll({ type: 'CONSOLE_CAPTURE', data: data });
        }
      };

      // Forward SELECTION_CHANGE events to all servers for selection tracking
      window.__wsForwardSelectionChange = function(data) {
        if (wsConnected) {
          broadcastToAll({ type: 'SELECTION_CHANGE', data: data });
        }
      };

      // Forward PAGE_CHANGE events to all servers for page tracking
      window.__wsForwardPageChange = function(data) {
        if (wsConnected) {
          broadcastToAll({ type: 'PAGE_CHANGE', data: data });
        }
      };

      // Start WebSocket connection via port scanning
      wsScanAndConnect();

      // Periodic background rescan every 30s to discover newly started MCP servers
      rescanTimerId = setInterval(function() {
        if (!isScanning) {
          wsScanAndConnect();
        }
      }, 30000);
    })();

    // ============================================================================
    // MESSAGE HANDLER - Process responses from plugin worker
    // ============================================================================
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;

      // Track activity for all plugin messages
      touchActivity();

      // Generic result handler
      const handleResult = (resultType, dataKey) => {
        const request = window.__figmaPendingRequests.get(msg.requestId);
        if (request) {
          if (request.timeoutId) clearTimeout(request.timeoutId);
          if (msg.success) {
            var result = { success: true };
            if (dataKey && msg[dataKey] !== undefined) result[dataKey] = msg[dataKey];
            if (msg.data !== undefined) result.data = msg.data;
            if (msg.oldName !== undefined) result.oldName = msg.oldName;
            if (msg.instance !== undefined) result.instance = msg.instance;
            request.resolve(result);
          } else {
            request.resolve({ success: false, error: msg.error || 'Unknown error' });
          }
          window.__figmaPendingRequests.delete(msg.requestId);
        }
      };

      // Handle message types
      switch (msg.type) {
        case 'VARIABLES_DATA':
          window.__figmaVariablesData = msg.data;
          window.__figmaVariablesReady = true;
          updateStatus('ready', true, false);
          console.log('[MCP Bridge] Active - ' + (msg.data.variables?.length || 0) + ' vars');
          // Forward to WebSocket client if connected
          if (window.__wsForwardVariables) window.__wsForwardVariables(msg.data);
          break;

        case 'COMPONENT_DATA':
          window.__figmaComponentData = msg.data;
          var req = window.__figmaComponentRequests.get(msg.requestId);
          if (req) { req.resolve(msg.data); window.__figmaComponentRequests.delete(msg.requestId); }
          break;

        case 'COMPONENT_ERROR':
          var req2 = window.__figmaComponentRequests.get(msg.requestId);
          if (req2) { req2.reject(new Error(msg.error)); window.__figmaComponentRequests.delete(msg.requestId); }
          break;

        case 'ERROR':
          window.__figmaVariablesReady = false;
          updateStatus('error', false, true);
          console.error('[MCP Bridge] Error:', msg.error);
          break;

        // Variable operations
        case 'EXECUTE_CODE_RESULT':
          handleResult('EXECUTE_CODE', 'result');
          break;
        case 'UPDATE_VARIABLE_RESULT':
          handleResult('UPDATE_VARIABLE', 'variable');
          break;
        case 'CREATE_VARIABLE_RESULT':
          handleResult('CREATE_VARIABLE', 'variable');
          break;
        case 'CREATE_VARIABLE_COLLECTION_RESULT':
          handleResult('CREATE_VARIABLE_COLLECTION', 'collection');
          break;
        case 'DELETE_VARIABLE_RESULT':
          handleResult('DELETE_VARIABLE', 'deleted');
          break;
        case 'DELETE_VARIABLE_COLLECTION_RESULT':
          handleResult('DELETE_VARIABLE_COLLECTION', 'deleted');
          break;
        case 'REFRESH_VARIABLES_RESULT':
          handleResult('REFRESH_VARIABLES', null);
          break;
        case 'RENAME_VARIABLE_RESULT':
          handleResult('RENAME_VARIABLE', 'variable');
          break;
        case 'SET_VARIABLE_DESCRIPTION_RESULT':
          handleResult('SET_VARIABLE_DESCRIPTION', 'variable');
          break;
        case 'ADD_MODE_RESULT':
          handleResult('ADD_MODE', 'collection');
          break;
        case 'RENAME_MODE_RESULT':
          handleResult('RENAME_MODE', 'collection');
          break;
        case 'GET_LOCAL_COMPONENTS_RESULT':
          handleResult('GET_LOCAL_COMPONENTS', null);
          break;
        case 'INSTANTIATE_COMPONENT_RESULT':
          handleResult('INSTANTIATE_COMPONENT', 'instance');
          break;

        // NEW: Component property operations
        case 'SET_NODE_DESCRIPTION_RESULT':
          handleResult('SET_NODE_DESCRIPTION', 'node');
          break;
        case 'ADD_COMPONENT_PROPERTY_RESULT':
          handleResult('ADD_COMPONENT_PROPERTY', 'propertyName');
          break;
        case 'EDIT_COMPONENT_PROPERTY_RESULT':
          handleResult('EDIT_COMPONENT_PROPERTY', 'propertyName');
          break;
        case 'DELETE_COMPONENT_PROPERTY_RESULT':
          handleResult('DELETE_COMPONENT_PROPERTY', null);
          break;

        // NEW: Node manipulation operations
        case 'RESIZE_NODE_RESULT':
          handleResult('RESIZE_NODE', 'node');
          break;
        case 'MOVE_NODE_RESULT':
          handleResult('MOVE_NODE', 'node');
          break;
        case 'SET_NODE_FILLS_RESULT':
          handleResult('SET_NODE_FILLS', 'node');
          break;
        case 'SET_NODE_STROKES_RESULT':
          handleResult('SET_NODE_STROKES', 'node');
          break;
        case 'SET_NODE_OPACITY_RESULT':
          handleResult('SET_NODE_OPACITY', 'node');
          break;
        case 'SET_NODE_CORNER_RADIUS_RESULT':
          handleResult('SET_NODE_CORNER_RADIUS', 'node');
          break;
        case 'CLONE_NODE_RESULT':
          handleResult('CLONE_NODE', 'node');
          break;
        case 'DELETE_NODE_RESULT':
          handleResult('DELETE_NODE', 'deleted');
          break;
        case 'RENAME_NODE_RESULT':
          handleResult('RENAME_NODE', 'node');
          break;
        case 'SET_TEXT_CONTENT_RESULT':
          handleResult('SET_TEXT_CONTENT', 'node');
          break;
        case 'CREATE_CHILD_NODE_RESULT':
          handleResult('CREATE_CHILD_NODE', 'node');
          break;

        // NEW: Screenshot and instance properties (visual validation loop fix)
        case 'CAPTURE_SCREENSHOT_RESULT':
          handleResult('CAPTURE_SCREENSHOT', 'image');
          break;
        case 'SET_INSTANCE_PROPERTIES_RESULT':
          handleResult('SET_INSTANCE_PROPERTIES', 'instance');
          break;

        // File info
        case 'GET_FILE_INFO_RESULT':
          handleResult('GET_FILE_INFO', 'fileInfo');
          break;

        // Plugin UI reload
        case 'RELOAD_UI_RESULT':
          handleResult('RELOAD_UI', null);
          break;

        // Document change events (for cache invalidation via WebSocket)
        case 'DOCUMENT_CHANGE':
          if (window.__wsForwardDocumentChange) window.__wsForwardDocumentChange(msg.data);
          break;

        // Console capture events (for console monitoring via WebSocket)
        case 'CONSOLE_CAPTURE':
          if (window.__wsForwardConsoleCapture) window.__wsForwardConsoleCapture(msg);
          break;

        // Selection change events (for selection tracking via WebSocket)
        case 'SELECTION_CHANGE':
          if (window.__wsForwardSelectionChange) window.__wsForwardSelectionChange(msg.data);
          break;

        // Page change events (for page tracking via WebSocket)
        case 'PAGE_CHANGE':
          if (window.__wsForwardPageChange) window.__wsForwardPageChange(msg.data);
          break;
      }
    };
  </script>
</body>
</html>
